{
  "Id": "3927lCQcqMl8My1",
  "ClassId": "5Di9JaQXaGuRf3r",
  "Author": "",
  "Version": 0,
  "CreatedAt": "2021-05-05T23:18:36.960685863+02:00",
  "UpdatedAt": "2021-10-31T22:26:50.130687044+01:00",
  "Name": "Electricity dashboard",
  "Group": "dashboards",
  "Description": "",
  "Nodes": [
    {
      "Id": "1",
      "Type": "http_trigger",
      "Label": "Dashboard page",
      "SuccessTransition": "17",
      "TimeoutTransition": "",
      "ErrorTransition": "",
      "Address": "",
      "Service": "",
      "ServiceInterface": "",
      "Config": {
        "AuthConfig": {
          "AuthCustomParamName": "",
          "AuthMethod": "none",
          "AuthPassword": "",
          "AuthToken": "",
          "AuthUsername": ""
        },
        "ConnectorID": "",
        "IsSync": true,
        "MapFormParamsToVars": true,
        "Method": "GET",
        "OutputVar": {
          "InMemory": true,
          "IsGlobal": false,
          "Name": "",
          "Type": "object"
        },
        "PayloadFormat": "form",
        "Timeout": 0
      },
      "Ui": {
        "nodeType": "",
        "x": 243,
        "y": 175
      },
      "TypeAlias": " Http/ws"
    },
    {
      "Id": "6",
      "Type": "http_trigger",
      "Label": "Websocket connection",
      "SuccessTransition": "15",
      "TimeoutTransition": "",
      "ErrorTransition": "",
      "Address": "",
      "Service": "",
      "ServiceInterface": "",
      "Config": {
        "AuthConfig": {
          "AuthCustomParamName": "",
          "AuthMethod": "none",
          "AuthPassword": "",
          "AuthToken": "",
          "AuthUsername": ""
        },
        "ConnectorID": "",
        "IsSync": true,
        "IsWs": true,
        "MapFormParamsToVars": false,
        "Method": "GET",
        "OutputVar": {
          "InMemory": true,
          "IsGlobal": false,
          "Name": "ws_msg",
          "Type": "object"
        },
        "PayloadFormat": "json",
        "Timeout": 0
      },
      "Ui": {
        "nodeType": "",
        "x": 522,
        "y": 181
      },
      "TypeAlias": " Http/ws"
    },
    {
      "Id": "15",
      "Type": "transform",
      "Label": "Set params",
      "SuccessTransition": "16",
      "TimeoutTransition": "",
      "ErrorTransition": "",
      "Address": "",
      "Service": "",
      "ServiceInterface": "",
      "Config": {
        "Expression": "",
        "IsLVariableGlobal": false,
        "IsRVariableGlobal": false,
        "IsTargetVariableGlobal": false,
        "IsTargetVariableInMemory": true,
        "LVariableName": "ws_msg",
        "RValue": {
          "Value": 0,
          "ValueType": "int"
        },
        "RVariableName": "",
        "Rtype": "var",
        "TargetVariableName": "",
        "TargetVariableType": "",
        "Template": "",
        "TransformType": "jpath",
        "ValueMapping": [],
        "XPathMapping": [
          {
            "IsTargetVariableGlobal": false,
            "IsTargetVariableInMemory": true,
            "Path": "$.val",
            "TargetVariableName": "service_state",
            "TargetVariableType": "bool",
            "UpdateInputVariable": false
          },
          {
            "IsTargetVariableGlobal": false,
            "IsTargetVariableInMemory": true,
            "Path": "$.addr",
            "TargetVariableName": "cmd_address",
            "TargetVariableType": "string",
            "UpdateInputVariable": false
          }
        ]
      },
      "Ui": {
        "nodeType": "",
        "x": 508,
        "y": 419
      },
      "TypeAlias": "Transform"
    },
    {
      "Id": "16",
      "Type": "action",
      "Label": "Controll lamp",
      "SuccessTransition": "",
      "TimeoutTransition": "",
      "ErrorTransition": "",
      "Address": "pt:j1/mt:cmd{{ variable \"cmd_address\" false }}",
      "Service": "out_bin_switch",
      "ServiceInterface": "cmd.binary.set",
      "Config": {
        "DefaultValue": {
          "Value": "",
          "ValueType": "bool"
        },
        "IsVariableGlobal": false,
        "Props": {},
        "RegisterAsVirtualService": false,
        "ResponseToTopic": "",
        "VariableName": "service_state",
        "VariableType": "bool",
        "VirtualServiceGroup": "",
        "VirtualServiceProps": {}
      },
      "Ui": {
        "nodeType": "",
        "x": 488,
        "y": 671
      },
      "TypeAlias": "Action"
    },
    {
      "Id": "17",
      "Type": "action_http_reply",
      "Label": "Send dashboard html template",
      "SuccessTransition": "",
      "TimeoutTransition": "",
      "ErrorTransition": "",
      "Address": "",
      "Service": "",
      "ServiceInterface": "",
      "Config": {
        "InputVar": {
          "InMemory": true,
          "IsGlobal": false,
          "Name": "",
          "Type": ""
        },
        "IsPublishOnly": false,
        "IsWs": false,
        "ResponsePayloadFormat": "html",
        "ResponseTemplate": "<html>\n  <head>\n   <script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"></script>\n   <script src=\"https://unpkg.com/vue@next\"></script>\n   <script src=\"https://cdn.plot.ly/plotly-2.4.2.min.js\"></script>\n   <script type=\"text/javascript\">\n      google.charts.load('current', {'packages':['gauge','corechart']});\n      google.charts.setOnLoadCallback(drawChart);\n      \n      var data ;\n      var lineData;\n      var chart ; \n      var lineChart;\n      var options;\n      var lineOptions;\n      var ws; \n      var reconnectCounter = 0;\n      \n      var locations;   \n      var devices;\n\n\t  var energyPrices = [];\n\t  var energyUsage = [];\n\n\t  var dev_id_to_name_map = {};\n\n      function drawChart() {\n        initLineChart();\n        configureWs();    \n        data = google.visualization.arrayToDataTable([\n          ['Label', 'Value'],\n          ['Server', 0],\n          ['Main power',0],\n          ['CO2 office',0],\n          ['Office T',0],\n          ['Outdoor T',0],\n         ]);\n\n        options = {\n          width: 750, height: 180,\n          redFrom: 2000, redTo: 3000,\n          yellowFrom:1000, yellowTo: 2000,\n          minorTicks: 5,\n          max:3000\n        };\n\n        chart = new google.visualization.Gauge(document.getElementById('chart_div'));\n        chart.draw(data, options); \n      }\n      \n      function setPlotlyChart() {\n        var time = new Date();\n\n        let layout ={\n            title: {\n                text:\"Power usage\",\n                font: {\n                family: \"Times New Roman\",\n                size: 24\n                },\n            },\n        }\n\n        let trace1 = {\n            x: [time],\n            y: [0],\n            mode: 'lines',\n            name: \"Tibber\",\n            line: {color: '#80CAF6'}\n        }\n       \n        var data = [trace1]\n        Plotly.newPlot('plotly_chart', data,layout);\n      }\n\n      var power_trace_index = {}\n      var temp_trace_index = {}\n      var humid_trace_index = {}\n      var co2_trace_index = {}\n      var lux_trace_index = {}\n\n      function setMultiPlotlyCharts(context) {\n        var time = new Date();\n        \n        let power_data = [];\n\t\tlet price_data = [];\n\t\tlet energy_data = [];\n        let temp_data = [];\n        let humid_data = [];\n        let co2_data = [];\n        let lux_data = [];\n\n        for (let loc of context) {\n            if (loc.Devices) {\n                for( let dev of loc.Devices) {\n                    if ( dev.states) {\n                        for ( let state of dev.states) {\n                               let trace = {\n                                    x: [state.UpdatedAt],\n                                    y: [state.Variable.Value],\n                                    mode: 'lines+markers',\n                                    name:  loc.alias + \" - \" +  dev.alias,\n                                }\n\t\t\t\t\t\t\t\tdev_id_to_name_map[dev.id] = loc.alias + \" - \" +  dev.alias;\n                                if (state.Name.includes(\"meter\")) {\n                                    trace.mode = 'lines'\n                                    power_trace_index[state.Name] = power_data.length\n                                    power_data.push(trace)\n                                }else if (state.Name.includes(\"sensor_temp\")) {\n                                    temp_trace_index[state.Name] = temp_data.length\n                                    temp_data.push(trace)\n                                }else if (state.Name.includes(\"sensor_humid\")) {\n                                    humid_trace_index[state.Name] = humid_data.length\n                                    humid_data.push(trace)    \n                                }else if (state.Name.includes(\"sensor_co2\")) {\n                                    co2_trace_index[state.Name] = co2_data.length\n                                    co2_data.push(trace)\n                                }else if (state.Name.includes(\"sensor_lumin\")) {\n                                    lux_trace_index[state.Name] = lux_data.length\n                                    lux_data.push(trace)\n                                }\n                                \n                        }  \n                    }\n                }\n            } \n            \n        }\n        \n        let price_trace = {\n                    x: [],\n                    y: [],\n                    mode: 'lines+markers',\n                    name:  \"Energy price\",\n        }\n\t\tlet energy_trace = {\n                    x: [],\n                    y: [],\n                    type:'bar'\n        }\n        \n        price_data.push(price_trace);\n\t\t// energy_data.push(energy_trace);\n\n        let power_layout = {title: {text:\"Power\"} } \n\t\t\n        \n\t\tlet price_layout = {title: {text:\"Energy price\"},xaxis: {\n\t\t    autorange: true,\n            type: 'date'\n          },yaxis: {\n            autorange: true,\n            type: 'linear',\n\t\t\ttitle: 'NOK per kWh',\n          }}       \n\t\tlet energy_layout = {title: {text:\"Energy\"},xaxis: {\n\t\t    autorange: true,\n            type: 'date'\n          },yaxis: {\n            autorange: true,\n            type: 'linear',\n\t\t\ttitle: 'kWh',\n          },barmode: 'stack'} \n\n        let temp_layout = {title: {text:\"Temperature\"} }               \n        let humid_layout = {title: {text:\"Humidity\"} }               \n        let co2_layout = {title: {text:\"Co2 level\"} }               \n        let lux_layout = {title: {text:\"Lux\"} }               \n        \n        Plotly.newPlot(\"power_plotly_chart\", power_data,power_layout); \n\t\tPlotly.newPlot(\"energy_plotly_chart\", energy_data,energy_layout); \n\t\tPlotly.newPlot(\"price_plotly_chart\", price_data,price_layout); \n        Plotly.newPlot(\"temp_plotly_chart\", temp_data,temp_layout);\n        Plotly.newPlot(\"humid_plotly_chart\", humid_data,humid_layout); \n        Plotly.newPlot(\"co2_plotly_chart\", co2_data,co2_layout); \n        Plotly.newPlot(\"lux_plotly_chart\", lux_data,lux_layout); \n\t    reloadHistory();\n\t\tsetInterval(function(){ reloadHistory() }, 1000*600);\n      }\n\n      function getStateNameFromMessage(msg) {\n          // pt:j1/mt:evt/rt:dev/rn:tibber/ad:1/sv:meter_elec/ad:12a889be-095a-47dd-8045-da84b57ae41d\n          // \"type\": \"evt.meter_ext.report\", \n          // state name : meter_ext@rt:dev/rn:tibber/ad:1/sv:meter_elec/ad:12a889be-095a-47dd-8045-da84b57ae41d\n          topic = msg.topic.replace(\"pt:j1/mt:evt/\",\"\")\n          typeS = msg.type.split(\".\")\n          return typeS[1]+\"@\"+topic\n\n      }\n\n      function updateTraceByTopic(state_name,value,time,props) {\n        var time = new Date();\n        // console.log(\"Updating state : \"+state_name)\n        if (state_name.includes(\"meter_ext\")) {\n            value = value.p_import;\n        }\n\n        var update = {\n            x:  [[time]],\n            y: [[value]],\n        }\n\n        if(state_name.includes(\"meter\")) {\n\t\t\tif (props)\n\t\t\t\tif (props[\"unit\"]==\"W\") {\n\t\t\t\t\ttrace_index = power_trace_index[state_name]\n\t\t\t\t\tPlotly.extendTraces('power_plotly_chart', update, [trace_index]) \n\t\t\t\t\tif(state_name.includes(\"tibber\")) {\n\t\t\t\t\tdata.setValue(1, 1, value);\n\t\t\t\t\tchart.draw(data, options);\n\t\t\t\t\t}\n\t\t\t}\n        }else if (state_name.includes(\"sensor_co2\")) {\n            trace_index = co2_trace_index[state_name]\n            Plotly.extendTraces('co2_plotly_chart', update, [trace_index])  \n        }else if (state_name.includes(\"sensor_temp\")) {\n            trace_index = temp_trace_index[state_name]\n            Plotly.extendTraces('temp_plotly_chart', update, [trace_index])  \n        }else if (state_name.includes(\"sensor_humid\")) {\n            trace_index = humid_trace_index[state_name]\n            Plotly.extendTraces('humid_plotly_chart', update, [trace_index])  \n        }else if (state_name.includes(\"sensor_lumin\")) {\n            trace_index = lux_trace_index[state_name]\n            Plotly.extendTraces('lux_plotly_chart', update, [trace_index])  \n        }\n        \n      }\n\n      function updateTraceByChartId(chartId,values) {\n        var update = {\n            x:  [[]],\n            y: [[]],\n\t    }  \n        for (let val of values) {\n                update.x[0].push(val[0]*1000)\n                update.y[0].push(val[1])\n        }\n        console.log(\"Updating TS trace for \"+chartId);\n        Plotly.extendTraces(chartId, update,[0]);\n      }\n\n\t  function addTraceByChartId(chartId,mValues) {\n\t\tlet meter_dev_id = \"100\"\n\t\tlet totals = []\t\n\t\tlet traces_to_remove = []\n\t\tfor(let i=0;i<mValues.length;i++) {\n\t\t\ttraces_to_remove.push(i);\n\t\t}\n\t\ttry {\n\t\t\tPlotly.deleteTraces(chartId, traces_to_remove);\n\t\t}catch {}\n\n\t\tfor (let values of mValues) {\n\t\t\tlet name = dev_id_to_name_map[values.tags.dev_id]\n\t\t\tlet trace = {x: [],y: [],type:'bar',name:name}\n\t\t\tif (values.tags.dev_id == meter_dev_id) {\n\t\t\t\ttotals = values\n\t\t\t\ttrace.type = \"line\"\n\t\t\t\ttrace.name = \"Main meter\"\n\t\t\t\tenergyUsage = values.values \t\n\t\t\t}\n\n\t\t\tfor (let val of values.values) {\n\t\t\t\t\ttrace.x.push(val[0]*1000)\n\t\t\t\t\ttrace.y.push(val[1])\n\t\t\t\t}\n\t\t\t\n\t\t\tPlotly.addTraces(chartId, trace);\n\t\t}\n\t\t\t\n      }\n\n      function updatePlotlyChart(val) {\n        var time = new Date();\n        var update = {\n            x:  [[time]],\n            y: [[val]]\n        }\n\n        Plotly.extendTraces('plotly_chart', update, [0])\n      }\n      \n   \n      function setAuthScroll() {\n  \n        var time = new Date();\n        \n        var olderTime = time.setMinutes(time.getMinutes() - 2);\n        var futureTime = time.setMinutes(time.getMinutes() + 2 );\n        \n        var minuteView = {\n                xaxis: {\n                type: 'date',\n                range: [olderTime,futureTime]\n                }\n            };\n        \n        Plotly.relayout('plotly_chart', minuteView);\n        }\n\n      function initLineChart() {\n        lineData = new google.visualization.DataTable();\n        lineData.addColumn('timeofday','Time');\n        lineData.addColumn('number','Main meter');\n        lineData.addColumn('number','Server');\n        lineOptions = {\n          title: 'Live power usage (W)',\n          curveType: 'function',\n          legend: { position: 'bottom' }\n        };\n         // lineChart = new google.visualization.LineChart(document.getElementById('curve_chart'));\n         // lineChart.draw(lineData, lineOptions);\n      }  \n      \n      function getFlowWsUrl() {\n           let flowWsUrl = \"\";\n           console.dir(location);\n           if(location.protocol==\"https:\") {\n              pathSp = location.pathname.split(\"/\");\n              flowWsUrl = \"wss://\";\n              return flowWsUrl+location.host+\"/cloud/\"+pathSp[2]+\"/flow/{{.FlowId}}/ws\"+location.search\n           }else {\n              flowWsUrl = \"ws://\";\n              return flowWsUrl+location.host+\"/flow/{{.FlowId}}/ws\"\n           }\n      }\n      \n      function getHttpApiUrl(comp) {\n          if(location.protocol==\"https:\") {\n              pathSp = location.pathname.split(\"/\");\n              return location.origin+\"/cloud/\"+pathSp[2]+comp+location.search\n           }else {\n              return location.origin+comp\n           }\n      }\n\n      function configureWs() {\n           ws = new WebSocket(getFlowWsUrl());\n                ws.onopen = function() {\n                };\n                 \n                ws.onmessage = function (evt) { \n                   var msg = JSON.parse(evt.data);\n                   if (msg.power) { // non-fimp message \n                       data.setValue(0, 1, msg.power.pc.p);\n                       data.setValue(1, 1, msg.power.main.p);\n                       chart.draw(data, options);\n                       updatePlotlyChart(msg.power.main.p)\n                       var dt = new Date();\n                       var tm = [dt.getHours(),dt.getMinutes(),dt.getSeconds()]\n                       lineData.addRow([tm,msg.power.main.p,msg.power.pc.p]);\n                       if (lineData.getNumberOfRows()>1000){\n                           lineData.removeRow(0);\n                       }\n                       document.getElementById(\"home_mode\").innerHTML = msg.home_mode;\n                       lineChart.draw(lineData, lineOptions);\n                   }else {\n                       if (msg.serv) { // fimp message \n                        //    console.dir(msg)\n                           state_name = getStateNameFromMessage(msg)\n                           updateTraceByTopic(state_name,msg.val,new Date(),msg.props);\n                           \n                           if (msg.serv==\"sensor_co2\") {\n                               data.setValue(2, 1, msg.val);\n                               chart.draw(data, options);\n                           }else if (msg.serv==\"sensor_temp\") {\n                               if (msg.topic.includes(\"02000032ea36\")) {\n                                   // outdoor sensor\n                                   data.setValue(4, 1, msg.val);\n                                   chart.draw(data, options);\n                               }else {\n                                   data.setValue(3, 1, msg.val);\n                                   chart.draw(data, options);\n                               }\n                               \n                           }\n                       }\n                   }\n                   \n                };\n                 \n                ws.onclose = function() { \n                   setTimeout(function() {\n                      configureWs();\n                    }, 1000);\n                   reconnectCounter++;\n                   document.getElementById(\"rCounter\").innerHTML = reconnectCounter++;\n                };\n      }\n      \n      function CtrlBinaryService(topic,state) {\n          let cmd = {\"op\":\"cmd.binary.set\",\"val\":state,\"addr\":topic};\n          ws.send(JSON.stringify(cmd));\n      }\n\n\t  function loadTimeseries(query) {\n\t\t    return fetch(getHttpApiUrl('/flow/timeseries/rest'), {method: 'post',body: JSON.stringify(query)})\n      }\n\t  \n\t  function reloadHistory() {\n\t\t  \n\t\t  loadEnergyTimeseries();\n\t  }\n\n      function loadPriceTimeseries() {\n\t\t    let query = {\n\t\t\t\t\"proc_id\":1,\n\t\t\t\t\"field_name\":\"value\",\n\t\t\t\t\"data_function\":\"max\",\n\t\t\t\t\"measurement_name\":\"sensor_price.evt.sensor.report\",\n\t\t\t\t\"relative_time\":\"1d\",\n\t\t\t\t\"group_by_time\":\"1h\",\n\t\t\t\t\"group_by_tag\":\"\",\n\t\t\t\t\"fill_type\":\"previous\"\n\t\t\t}\n            loadTimeseries(query).then((response)=> {\n                        if (response.status !== 200) {\n                            console.log('Failed to load TS.Status Code: '+response.status);\n                            return;\n                        }\n                        response.json().then((data) => {\n                            energyPrices = data[0].values;\n\t\t\t\t\t\t\tupdateTraceByChartId(\"price_plotly_chart\",data[0].values);\n\t\t\t\t\t\t\tcomputeEnergyTotals();\n\t\t\t\t\t\t\t\n                        });\n                        }).catch(function(err) {\n                            console.log('Context fetch Error :-S', err);\n                        });\n      }\n\n\t  function loadEnergyTimeseries() {\n\t\t    let query = {\n\t\t\t\t\"proc_id\":1,\n\t\t\t\t\"measurement_name\":\"energy_data_points\",\n\t\t\t\t\"relative_time\":\"1d\",\n\t\t\t\t\"group_by_time\":\"1h\",\n\t\t\t\t\"group_by_tag\":\"dev_id\",\n\t\t\t}\n            loadTimeseries(query).then((response)=> {\n                        if (response.status !== 200) {\n                            console.log('Failed to load TS.Status Code: '+response.status);\n                            return;\n                        }\n                        response.json().then((data) => {\n                            addTraceByChartId(\"energy_plotly_chart\",data);\n\t\t\t\t\t\t\tloadPriceTimeseries();\n                        });\n                        }).catch(function(err) {\n                            console.log('Context fetch Error :-S', err);\n                        });\n      }\n\n\t  function computeEnergyTotals() {\n\t\t  let totalEnergy = 0; \n\t\t  let totalCost = 0;\n\t\t  let trace1 = {x: [],y: [],type:'line',name:\"Costs per hour\"}\n\t\t  let trace2 = {x: [],y: [],type:'line',name:\"Costs accumulated\",visible:\"legendonly\"}\n\t\t  \n\t\t  for (let i=0;i<energyUsage.length;i++) {\n\t\t\t  if (energyUsage[i][0] == energyPrices[i][0]) {\n\t\t\t\t  eUsage = energyUsage[i][1];\n\t\t\t\t  ePrice = energyPrices[i][1];\n\t\t\t\t  if (eUsage!=null && ePrice != null) {\n\t\t\t\t\t  cost = eUsage * ePrice;\n\t\t\t\t\t  totalCost += cost;\n\t\t\t\t\t  console.log(\"New cost = \",cost);\n\t\t\t\t\t  trace1.y.push(cost);\n\t\t\t\t\t  trace1.x.push(energyUsage[i][0]*1000);\n\n\t\t\t\t\t  trace2.y.push(totalCost);\n\t\t\t\t\t  trace2.x.push(energyUsage[i][0]*1000);\n\t\t\t\t  }\n\t\t\t\t  totalEnergy += eUsage \n\t\t\t  }else {\n\t\t\t\t  console.log(\"Time don't match\")\n\t\t\t  }\n\t\t  }\n\t\t  totalCost = Math.round(totalCost*100)/100;\n\t\t  totalEnergy = Math.round(totalEnergy*100)/100;\n\t\t  document.getElementById(\"energy_total\").innerHTML = \"Total energy consumed = \"+totalEnergy+\" kWh , monthly projection = \"+totalEnergy*30+\" kWh\"\n\t\t  document.getElementById(\"energy_costs_total\").innerHTML = \"Total accumulated cost = \"+totalCost+\" NOK , monthly projection = \"+totalCost*30+\" NOK\"\n \n\t\t  try {\n\t\t\tPlotly.deleteTraces(\"price_plotly_chart\", [1,2]);\n\t\t  }catch {}\n\t\t  Plotly.addTraces(\"price_plotly_chart\", [trace1,trace2]);\n\t  }\n    \n      const HomeDash = {\n                delimiters: ['${', '}'],    \n                data() {\n                    return {\n                    counter: 0,\n                    locations:[],\n                    }\n                },\n                methods: {\n                    loadFullStructAndStates() {\n                        fetch(getHttpApiUrl('/api/flow/context/full_struct_and_states')).then((response)=> {\n                        if (response.status !== 200) {\n                            console.log('Looks like there was a problem. Status Code: ' +\n                            response.status);\n                            return;\n                        }\n                        response.json().then((data) => {\n                            this.locations = data;\n                            setMultiPlotlyCharts(data);\n                        });\n                        }).catch(function(err) {\n                            console.log('Context fetch Error :-S', err);\n                        });\n                    },\n                    CtrlBinaryService    \n                },\n                mounted() {\n                    this.loadFullStructAndStates();\n                    setInterval(() => {\n                    this.counter++\n                    }, 1000)\n                }\n    }\n         \n    </script>\n  </head>\n  <body>\n    <p>Home mode:<b id=\"home_mode\"></b></p>  \n    <div id=\"chart_div\" style=\"width: 750px; height: 180px;\"></div>\n    \n    <div id=\"plotly_chart\"></div>\n\t<button onclick=\"reloadHistory()\"> Reload history </button>   \n\t<button onclick=\"computeEnergyTotals()\"> Compute costs </button>   \n    <div id=\"power_plotly_chart\"></div>\n\t<div id=\"energy_plotly_chart\"></div>\n\t<div id=\"energy_total\">Total energy consumed =</div><div id=\"energy_costs_total\">Total accumulated cost =</div>\n\t<div id=\"price_plotly_chart\"></div>\n    <div id=\"temp_plotly_chart\"></div>\n    <div id=\"humid_plotly_chart\"></div>\n    <div id=\"co2_plotly_chart\"></div>\n    <div id=\"lux_plotly_chart\"></div>\n    \n    <div> \n       <button onclick=\"CtrlBinaryService('1',true)\"> Turn ON </button> \n       <button onclick=\"CtrlBinaryService('1',false)\"> Turn OFF </button>    \n    </div>\n    \n    <p id=\"rCounter\"></p>\n\n    <p>Locations</p>\n\n    <div id=\"loc_div\">\n        Counter: ${ counter }\n        \n        <ul>\n        <li v-for=\"loc in locations\" :key=\"loc.id\" >\n          <h3>${ loc.alias }</h3>\n          <div v-for=\"dev in loc.Devices\" :key=\"dev.id\" >\n              <h4>${ dev.alias}</h4> \n              <div v-for=\"svc in dev.services\"> \n                <div v-if=\"svc.name == 'out_bin_switch'\"> \n                    <button @click=\"CtrlBinaryService(svc.address,true)\"> on </button> \n                    <button @click=\"CtrlBinaryService(svc.address,false)\"> off </button>    \n                </div> \n              </div>\n              <div v-for=\"state in dev.states\" v-bind:id=\"state.Name\" >\n                 State : ${state.Name } , value = ${state.Variable.Value} , Updated at : ${state.UpdatedAt}\n              </div>\n          </div>\n        </li>\n        </ul>\n    </div>\n   <script>\n      Vue.createApp(HomeDash).mount('#loc_div')\n  </script>\n\n\n  </body>\n  \n</html>\n"
      },
      "Ui": {
        "nodeType": "",
        "x": 224,
        "y": 430
      },
      "TypeAlias": "Http reply"
    },
    {
      "Id": "18",
      "Type": "trigger",
      "Label": "Stream all device events over WS",
      "SuccessTransition": "19",
      "TimeoutTransition": "",
      "ErrorTransition": "",
      "Address": "pt:j1/mt:evt/rt:dev/#",
      "Service": "*",
      "ServiceInterface": "*",
      "Config": {
        "IsValueFilterEnabled": false,
        "LookupServiceNameAndLocation": false,
        "RegisterAsVirtualService": false,
        "Timeout": 0,
        "ValueFilter": {
          "Value": "",
          "ValueType": "float"
        },
        "VirtualServiceGroup": "ch_0",
        "VirtualServiceProps": {}
      },
      "Ui": {
        "nodeType": "",
        "x": 873,
        "y": 174
      },
      "TypeAlias": "Trigger"
    },
    {
      "Id": "19",
      "Type": "action_http_reply",
      "Label": "Forwarding sensor data over WS",
      "SuccessTransition": "",
      "TimeoutTransition": "",
      "ErrorTransition": "",
      "Address": "",
      "Service": "",
      "ServiceInterface": "",
      "Config": {
        "InputVar": {
          "InMemory": true,
          "IsGlobal": false,
          "Name": "",
          "Type": ""
        },
        "IsPublishOnly": false,
        "IsWs": true,
        "ResponsePayloadFormat": "json",
        "ResponseTemplate": ""
      },
      "Ui": {
        "nodeType": "",
        "x": 850,
        "y": 664
      },
      "TypeAlias": "Http reply"
    }
  ],
  "Settings": {
    "address": {
      "Value": "cube.local:8082",
      "ValueType": "string"
    }
  },
  "IsDisabled": false,
  "IsDefault": false,
  "ParallelExecution": "parallel"
}